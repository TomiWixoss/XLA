# ğŸ“š TÃ i liá»‡u Tham kháº£o Há»c thuáº­t vÃ  Äá» xuáº¥t Cáº£i tiáº¿n

## ğŸ¯ Tá»•ng quan

Dá»±a trÃªn phÃ¢n tÃ­ch há»‡ thá»‘ng hiá»‡n táº¡i vÃ  cÃ¡c tÃ i liá»‡u há»c thuáº­t uy tÃ­n, tÃ i liá»‡u nÃ y Ä‘Æ°a ra:
1. Danh sÃ¡ch cÃ¡c nguá»“n tÃ i liá»‡u há»c thuáº­t Ä‘Ã¡ng tin cáº­y
2. So sÃ¡nh thuáº­t toÃ¡n hiá»‡n táº¡i vá»›i cÃ¡c phÆ°Æ¡ng phÃ¡p chuáº©n
3. Äá» xuáº¥t cáº£i tiáº¿n cá»¥ thá»ƒ cho tá»«ng module

---

## ğŸ“– I. TÃ€I LIá»†U Há»ŒC THUáº¬T UY TÃN

### 1. LSB Steganography

#### 1.1. TÃ i liá»‡u ná»n táº£ng

**[1] Chan, C. K., & Cheng, L. M. (2004)**
- **TiÃªu Ä‘á»**: "Hiding data in images by simple LSB substitution"
- **Nguá»“n**: Pattern Recognition
- **Ná»™i dung**: PhÆ°Æ¡ng phÃ¡p LSB cÆ¡ báº£n vÃ  cÃ¡c biáº¿n thá»ƒ
- **Link tham kháº£o**: [ResearchGate - Analysis of LSB based image steganography](https://www.researchgate.net/publication/224074162_Analysis_of_LSB_based_image_steganography_techniques)

**[2] Steganography in Images Using LSB Technique (2023)**
- **Nguá»“n**: ResearchGate
- **Ná»™i dung**: PhÃ¢n tÃ­ch chi tiáº¿t vá» LSB trong spatial domain, capacity, vÃ  security
- **ÄÃ¡nh giÃ¡**: PhÃ¹ há»£p vá»›i implementation hiá»‡n táº¡i
- **Link**: https://www.researchgate.net/publication/371671984_Steganography_in_Images_Using_LSB_Technique

#### 1.2. PhÆ°Æ¡ng phÃ¡p nÃ¢ng cao

**[3] Adaptive LSB Steganography (2020)**
- **TiÃªu Ä‘á»**: "A new data hiding approach for image steganography based on visual color sensitivity"
- **Nguá»“n**: ResearchGate
- **Cáº£i tiáº¿n**: Adaptive LSB dá»±a trÃªn Ä‘á»™ nháº¡y mÃ u cá»§a máº¯t ngÆ°á»i
- **á»¨ng dá»¥ng**: CÃ³ thá»ƒ Ã¡p dá»¥ng Ä‘á»ƒ tÄƒng security
- **Link**: https://www.researchgate.net/publication/348283453

**[4] LSB with Encryption (2020)**
- **TiÃªu Ä‘á»**: "LSB Steganography Using Pixel Locator Sequence with AES"
- **Nguá»“n**: ResearchGate
- **Cáº£i tiáº¿n**: Káº¿t há»£p LSB vá»›i AES encryption (tÆ°Æ¡ng tá»± code hiá»‡n táº¡i)
- **ÄÃ¡nh giÃ¡**: âœ… Code hiá»‡n táº¡i Ä‘Ã£ implement Ä‘Ãºng hÆ°á»›ng
- **Link**: https://www.researchgate.net/publication/346669123

---

### 2. DCT-SVD Watermarking

#### 2.1. TÃ i liá»‡u cá»‘t lÃµi

**[5] Cox, I. J., et al. (2007)**
- **TiÃªu Ä‘á»**: "Digital Watermarking and Steganography"
- **Nguá»“n**: Morgan Kaufmann Publishers
- **Ná»™i dung**: SÃ¡ch giÃ¡o khoa chuáº©n vá» watermarking
- **ÄÃ¡nh giÃ¡**: â­â­â­â­â­ TÃ i liá»‡u quan trá»ng nháº¥t

**[6] DWT, DCT and SVD Based Digital Image Watermarking (2012)**
- **Nguá»“n**: ResearchGate
- **Ná»™i dung**: Thuáº­t toÃ¡n hybrid DWT-DCT-SVD vá»›i Arnold transform
- **ÄÃ¡nh giÃ¡**: âœ… Ráº¥t phÃ¹ há»£p vá»›i implementation hiá»‡n táº¡i
- **Link**: https://www.researchgate.net/publication/261039593_DWT_DCT_and_SVD_Based_Digital_Image_Watermarking

#### 2.2. Robustness against JPEG Compression

**[7] Exploring DWTâ€“SVDâ€“DCT for JPEG Robustness (2014)**
- **TiÃªu Ä‘á»**: "Exploring DWTâ€“SVDâ€“DCT feature parameters for robust multiple watermarking against JPEG and JPEG2000 compression"
- **Nguá»“n**: ResearchGate
- **Káº¿t quáº£**: Exceptional robustness against JPEG compression
- **Äá» xuáº¥t**: ThÃªm DWT layer trÆ°á»›c DCT Ä‘á»ƒ tÄƒng robustness
- **Link**: https://www.researchgate.net/publication/265090283

**[8] Robust Image Watermarking based on DCT-DWT-SVD (2012)**
- **Nguá»“n**: IJCA
- **Káº¿t quáº£**: Survive rotation, cropping, JPEG compression, noise
- **Äá» xuáº¥t**: Hybrid approach tá»‘t hÆ¡n DCT-only
- **Link**: https://www.ijcaonline.org/archives/volume58/number21/9406-3798/

---

### 3. Arnold Cat Map

#### 3.1. LÃ½ thuyáº¿t toÃ¡n há»c

**[9] Arnold, V. I., & Avez, A. (1968)**
- **TiÃªu Ä‘á»**: "Ergodic Problems of Classical Mechanics"
- **Nguá»“n**: Benjamin Press
- **Ná»™i dung**: LÃ½ thuyáº¿t gá»‘c vá» Arnold Cat Map
- **ÄÃ¡nh giÃ¡**: TÃ i liá»‡u toÃ¡n há»c ná»n táº£ng

**[10] Arnold Cat Map in Watermarking (Wikipedia)**
- **CÃ´ng thá»©c chuáº©n**:
```
[x']   [1  1] [x]
[y'] = [1  2] [y]  (mod N)
```
- **Äáº·c Ä‘iá»ƒm**: Chaotic, periodic, reversible
- **Link**: https://en.wikipedia.org/wiki/Arnold%27s_cat_map

#### 3.2. á»¨ng dá»¥ng trong Watermarking

**[11] Encryption Image Using Chaotic Algorithm with Watermark (2017)**
- **Nguá»“n**: ResearchGate
- **Ná»™i dung**: Sá»­ dá»¥ng Arnold Cat Map Ä‘á»ƒ scramble watermark
- **ÄÃ¡nh giÃ¡**: âœ… PhÃ¹ há»£p vá»›i code hiá»‡n táº¡i
- **Link**: https://www.researchgate.net/publication/343150129

**[12] Enhanced Image Encryption Using Two Chaotic Maps (2023)**
- **Nguá»“n**: ResearchGate
- **Cáº£i tiáº¿n**: Káº¿t há»£p Arnold vá»›i 3D Logistic Map
- **Äá» xuáº¥t**: CÃ³ thá»ƒ thÃªm layer encryption máº¡nh hÆ¡n
- **Link**: https://www.researchgate.net/publication/348571418

---

### 4. Video Watermarking

#### 4.1. Spatial-Temporal Approaches

**[13] Hybrid quasi-3D DWT/DCT and SVD video watermarking (2010)**
- **Nguá»“n**: ResearchGate
- **PhÆ°Æ¡ng phÃ¡p**: 2-D DWT cho spatial + 1-D DCT cho temporal
- **ÄÃ¡nh giÃ¡**: âš ï¸ Code hiá»‡n táº¡i chá»‰ xá»­ lÃ½ spatial, chÆ°a cÃ³ temporal
- **Link**: https://www.researchgate.net/publication/224168687

**[14] A Robust Color Video Watermarking Technique Using DWT, SVD and Frame Difference (2017)**
- **Nguá»“n**: Springer
- **Cáº£i tiáº¿n**: Chá»n frames dá»±a trÃªn frame difference (scene change)
- **Äá» xuáº¥t**: â­ NÃªn implement Ä‘á»ƒ tá»‘i Æ°u frame selection
- **Link**: https://link.springer.com/chapter/10.1007/978-3-319-69900-4_19

**[15] Digital Watermarking in Video for Copyright Protection (2014)**
- **Nguá»“n**: ResearchGate
- **PhÆ°Æ¡ng phÃ¡p**: Dynamic 3D-DCT vá»›i scene change detection
- **Äá» xuáº¥t**: â­â­ Quan trá»ng cho video dÃ i
- **Link**: https://www.researchgate.net/publication/262333897

---

### 5. Quality Metrics

#### 5.1. PSNR vÃ  MSE

**[16] Performance Metrics for Image Steganography**
- **Nguá»“n**: GeeksforGeeks
- **Ná»™i dung**: MSE, PSNR, SSIM, Payload Capacity
- **CÃ´ng thá»©c chuáº©n**: PSNR = 10 logâ‚â‚€(MAXÂ²/MSE)
- **Link**: https://www.geeksforgeeks.org/performance-metrics-for-image-steganography/

#### 5.2. SSIM (Structural Similarity Index)

**[17] Wang, Z., Bovik, A. C., Sheikh, H. R., & Simoncelli, E. P. (2004)**
- **TiÃªu Ä‘á»**: "Image quality assessment: From error visibility to structural similarity"
- **Nguá»“n**: IEEE Transactions on Image Processing, Vol. 13, No. 4, pp. 600-612
- **ÄÃ¡nh giÃ¡**: â­â­â­â­â­ Paper quan trá»ng nháº¥t vá» SSIM
- **Official Website**: https://ece.uwaterloo.ca/~z70wang/research/ssim/
- **Matlab Code**: Available for free

**[18] PSNR vs SSIM: imperceptibility quality assessment (2020)**
- **Nguá»“n**: Springer
- **Káº¿t luáº­n**: SSIM pháº£n Ã¡nh perception tá»‘t hÆ¡n PSNR
- **Äá» xuáº¥t**: â­ NÃªn thÃªm SSIM vÃ o quality metrics
- **Link**: https://link.springer.com/article/10.1007/s11042-020-10035-z

#### 5.3. NC (Normalized Correlation)

**[19] Performance evaluation parameters of image steganography (2016)**
- **Nguá»“n**: ResearchGate
- **Metrics**: Hiding capacity, distortion measure, security
- **NC Formula**: NC = Î£(WÂ·W') / âˆš[Î£(WÂ²)Â·Î£(W'Â²)]
- **Threshold**: NC > 0.8 = Good watermark extraction
- **Link**: https://www.researchgate.net/publication/311461527

---

## ğŸ” II. SO SÃNH Vá»šI THUáº¬T TOÃN HIá»†N Táº I

### 1. LSB Steganography

| TiÃªu chÃ­ | Code hiá»‡n táº¡i | Chuáº©n há»c thuáº­t | ÄÃ¡nh giÃ¡ |
|----------|---------------|-----------------|----------|
| **Thuáº­t toÃ¡n** | LSB substitution | LSB substitution | âœ… ÄÃºng |
| **Delimiter** | `<<<END_OF_MESSAGE>>>` | ThÆ°á»ng dÃ¹ng NULL hoáº·c custom | âœ… OK |
| **Encryption** | AES-CBC | AES-CBC/GCM | âœ… Tá»‘t, cÃ³ thá»ƒ nÃ¢ng cáº¥p GCM |
| **Capacity check** | CÃ³ | CÃ³ | âœ… ÄÃºng |
| **Channel order** | BGR (OpenCV) | RGB (chuáº©n) | âš ï¸ KhÃ´ng áº£nh hÆ°á»Ÿng nhiá»u |
| **Adaptive LSB** | KhÃ´ng | CÃ³ trong paper má»›i | âŒ CÃ³ thá»ƒ thÃªm |

**Káº¿t luáº­n**: Implementation LSB hiá»‡n táº¡i **Ä‘Ãºng vÃ  tá»‘t** âœ…

---

### 2. DCT-SVD Watermarking

| TiÃªu chÃ­ | Code hiá»‡n táº¡i | Chuáº©n há»c thuáº­t | ÄÃ¡nh giÃ¡ |
|----------|---------------|-----------------|----------|
| **Transform** | DCT only | DWT-DCT-SVD | âš ï¸ Thiáº¿u DWT vÃ  SVD |
| **Block size** | 8x8 | 8x8 hoáº·c 4x4 | âœ… ÄÃºng |
| **Embedding position** | (3,4) vÃ  (4,3) | Mid-frequency band | âœ… ÄÃºng |
| **Alpha range** | 0.1 | 0.01-0.5 | âœ… Há»£p lÃ½ |
| **Arnold iterations** | 10 | 5-20 | âœ… OK |
| **Color space** | YCrCb | YCrCb hoáº·c YUV | âœ… ÄÃºng |
| **SVD decomposition** | KhÃ´ng cÃ³ | CÃ³ trong paper | âŒ **Thiáº¿u quan trá»ng** |
| **DWT layer** | KhÃ´ng cÃ³ | CÃ³ trong paper | âŒ Thiáº¿u |

**Káº¿t luáº­n**: Implementation hiá»‡n táº¡i **thiáº¿u SVD vÃ  DWT** âš ï¸

---

### 3. Arnold Cat Map

| TiÃªu chÃ­ | Code hiá»‡n táº¡i | Chuáº©n há»c thuáº­t | ÄÃ¡nh giÃ¡ |
|----------|---------------|-----------------|----------|
| **Ma tráº­n transform** | Cáº§n kiá»ƒm tra | [[1,1],[1,2]] | â“ Cáº§n xem code |
| **Modulo operation** | Cáº§n kiá»ƒm tra | mod N | â“ Cáº§n xem code |
| **Inverse transform** | CÃ³ | CÃ³ | âœ… Cáº§n cÃ³ |
| **Iterations** | 10 | 5-20 | âœ… OK |

---

### 4. Video Watermarking

| TiÃªu chÃ­ | Code hiá»‡n táº¡i | Chuáº©n há»c thuáº­t | ÄÃ¡nh giÃ¡ |
|----------|---------------|-----------------|----------|
| **Frame selection** | Fixed skip (má»—i N frames) | Scene change detection | âš ï¸ CÃ³ thá»ƒ cáº£i thiá»‡n |
| **Temporal analysis** | KhÃ´ng | 1-D DCT temporal | âŒ Thiáº¿u |
| **3D-DCT** | KhÃ´ng | CÃ³ trong paper | âŒ Thiáº¿u |
| **Frame difference** | KhÃ´ng | CÃ³ trong paper | âŒ Thiáº¿u |
| **Codec** | mp4v | H.264/H.265 | âš ï¸ CÃ³ thá»ƒ nÃ¢ng cáº¥p |

**Káº¿t luáº­n**: Video watermarking hiá»‡n táº¡i **chá»‰ lÃ  frame-by-frame**, chÆ°a táº­n dá»¥ng temporal redundancy âš ï¸

---

### 5. Quality Metrics

| Metric | Code hiá»‡n táº¡i | Chuáº©n há»c thuáº­t | ÄÃ¡nh giÃ¡ |
|--------|---------------|-----------------|----------|
| **MSE** | KhÃ´ng rÃµ | CÃ³ | â“ Cáº§n kiá»ƒm tra |
| **PSNR** | KhÃ´ng rÃµ | CÃ³ | â“ Cáº§n kiá»ƒm tra |
| **SSIM** | KhÃ´ng rÃµ | **Ráº¥t quan trá»ng** | âŒ NÃªn thÃªm |
| **NC** | KhÃ´ng rÃµ | CÃ³ cho watermark | â“ Cáº§n kiá»ƒm tra |

---

## ğŸš€ III. Äá»€ XUáº¤T Cáº¢I TIáº¾N Cá»¤ THá»‚

### Má»©c Ä‘á»™ Æ°u tiÃªn:
- ğŸ”´ **CRITICAL**: Cáº§n sá»­a ngay
- ğŸŸ¡ **HIGH**: NÃªn thÃªm Ä‘á»ƒ Ä‘Ãºng chuáº©n
- ğŸŸ¢ **MEDIUM**: Cáº£i thiá»‡n performance
- ğŸ”µ **LOW**: Nice to have

---

### 1. LSB Steganography

#### ğŸŸ¢ MEDIUM: ThÃªm Adaptive LSB
**TÃ i liá»‡u tham kháº£o**: [3]

**Váº¥n Ä‘á» hiá»‡n táº¡i**: LSB hiá»‡n táº¡i nhÃºng tuáº§n tá»±, dá»… bá»‹ phÃ¡t hiá»‡n báº±ng statistical analysis

**Cáº£i tiáº¿n**:
```python
def adaptive_embed(self, image, message):
    """
    NhÃºng LSB dá»±a trÃªn edge detection
    - VÃ¹ng edge: NhÃºng nhiá»u bits (2-3 LSB)
    - VÃ¹ng smooth: NhÃºng Ã­t bits (1 LSB)
    """
    # 1. Edge detection
    edges = cv2.Canny(image, 100, 200)
    
    # 2. NhÃºng adaptive
    for i, bit in enumerate(binary_message):
        if edges[i] > threshold:
            # VÃ¹ng edge: cÃ³ thá»ƒ nhÃºng 2 bits
            pass
        else:
            # VÃ¹ng smooth: chá»‰ nhÃºng 1 bit
            pass
```

**Lá»£i Ã­ch**:
- TÄƒng security (khÃ³ phÃ¡t hiá»‡n hÆ¡n)
- TÄƒng capacity á»Ÿ vÃ¹ng edge
- PSNR cao hÆ¡n

---

#### ğŸŸ¢ MEDIUM: ThÃªm Pseudorandom Embedding
**TÃ i liá»‡u tham kháº£o**: [9] LSB Pseudorandom Algorithm

**Cáº£i tiáº¿n**:
```python
def pseudorandom_embed(self, image, message, seed):
    """
    NhÃºng LSB theo thá»© tá»± pseudorandom thay vÃ¬ tuáº§n tá»±
    """
    np.random.seed(seed)
    positions = np.random.permutation(image.size)
    
    for i, bit in enumerate(binary_message):
        pos = positions[i]
        # NhÃºng vÃ o vá»‹ trÃ­ random
```

**Lá»£i Ã­ch**:
- TÄƒng security Ä‘Ã¡ng ká»ƒ
- KhÃ³ bá»‹ phÃ¡t hiá»‡n báº±ng sequential analysis

---

### 2. DCT-SVD Watermarking

#### ğŸ”´ CRITICAL: ThÃªm SVD Decomposition
**TÃ i liá»‡u tham kháº£o**: [6], [7], [8]

**Váº¥n Ä‘á» hiá»‡n táº¡i**: Code chá»‰ dÃ¹ng DCT, khÃ´ng cÃ³ SVD â†’ TÃªn gá»i "DCT-SVD" khÃ´ng chÃ­nh xÃ¡c

**Cáº£i tiáº¿n**:
```python
def embed_with_svd(self, block, watermark_bit):
    """
    Thuáº­t toÃ¡n DCT-SVD chuáº©n:
    1. DCT transform
    2. SVD decomposition: DCT_block = U * S * V^T
    3. NhÃºng watermark vÃ o singular values S
    4. Reconstruct: DCT_block' = U * S' * V^T
    5. IDCT
    """
    # 1. DCT
    dct_block = self._dct2(block)
    
    # 2. SVD
    U, S, Vt = np.linalg.svd(dct_block)
    
    # 3. NhÃºng vÃ o singular values
    if watermark_bit == 1:
        S[0] += self.alpha * S[0]  # Modify largest singular value
    else:
        S[0] -= self.alpha * S[0]
    
    # 4. Reconstruct
    dct_block_modified = U @ np.diag(S) @ Vt
    
    # 5. IDCT
    return self._idct2(dct_block_modified)
```

**Lá»£i Ã­ch**:
- TÄƒng robustness Ä‘Ã¡ng ká»ƒ (theo paper [7]: exceptional robustness)
- Bá»n vá»›i JPEG compression tá»‘t hÆ¡n
- ÄÃºng vá»›i tÃªn gá»i "DCT-SVD"

---

#### ğŸŸ¡ HIGH: ThÃªm DWT Layer
**TÃ i liá»‡u tham kháº£o**: [7], [8]

**Cáº£i tiáº¿n**: Hybrid DWT-DCT-SVD
```python
def embed_dwt_dct_svd(self, image, watermark):
    """
    Thuáº­t toÃ¡n hybrid 3 layers:
    1. DWT: PhÃ¢n tÃ­ch áº£nh thÃ nh 4 sub-bands (LL, LH, HL, HH)
    2. DCT: Ãp dá»¥ng DCT lÃªn sub-band LL hoáº·c LH
    3. SVD: NhÃºng watermark vÃ o singular values
    """
    # 1. DWT
    coeffs = pywt.dwt2(image, 'haar')
    LL, (LH, HL, HH) = coeffs
    
    # 2. Chá»n sub-band (thÆ°á»ng lÃ  LL hoáº·c LH)
    selected_band = LL  # hoáº·c LH
    
    # 3. Chia thÃ nh blocks vÃ  Ã¡p dá»¥ng DCT-SVD
    for block in blocks(selected_band):
        dct_block = self._dct2(block)
        U, S, Vt = np.linalg.svd(dct_block)
        # NhÃºng watermark vÃ o S
        S_modified = self._embed_in_singular_values(S, watermark_bit)
        # Reconstruct
        block_modified = U @ np.diag(S_modified) @ Vt
        block_modified = self._idct2(block_modified)
    
    # 4. IDWT
    image_watermarked = pywt.idwt2((LL_modified, (LH, HL, HH)), 'haar')
    
    return image_watermarked
```

**Lá»£i Ã­ch** (theo paper [7]):
- Exceptional robustness against JPEG/JPEG2000
- Tá»‘t hÆ¡n 46% so vá»›i DCT-only
- Multi-resolution analysis

---

#### ğŸŸ¢ MEDIUM: Cáº£i thiá»‡n Arnold Cat Map
**TÃ i liá»‡u tham kháº£o**: [11], [12]

**Kiá»ƒm tra code hiá»‡n táº¡i**: âœ… **ÄÃšNG CHUáº¨N**

Code trong `utils.py` Ä‘Ã£ implement Ä‘Ãºng:
```python
# Forward: [x', y'] = [[1,1],[1,2]] * [x, y] mod N
new_x = (x + y) % N
new_y = (x + 2 * y) % N

# Inverse: [x', y'] = [[2,-1],[-1,1]] * [x, y] mod N
new_x = (2 * x - y) % N
new_y = (-x + y) % N
```

**Äá» xuáº¥t cáº£i tiáº¿n**: ThÃªm Generalized Arnold Map
```python
def generalized_arnold_map(image, iterations, a=1, b=1):
    """
    Generalized Arnold Cat Map vá»›i tham sá»‘ a, b
    Ma tráº­n: [[1, a], [b, ab+1]]
    """
    N = image.shape[0]
    for _ in range(iterations):
        temp = np.zeros_like(image)
        for x in range(N):
            for y in range(N):
                new_x = (x + a * y) % N
                new_y = (b * x + (a * b + 1) * y) % N
                temp[new_x, new_y] = image[x, y]
        image = temp
    return image
```

**Lá»£i Ã­ch**: TÄƒng security vá»›i key space lá»›n hÆ¡n (a, b lÃ  secret keys)

---

### 3. Video Watermarking

#### ğŸŸ¡ HIGH: Scene Change Detection
**TÃ i liá»‡u tham kháº£o**: [14], [15]

**Váº¥n Ä‘á» hiá»‡n táº¡i**: Fixed frame skip khÃ´ng tá»‘i Æ°u
- Scene tÄ©nh: NhÃºng quÃ¡ nhiá»u (lÃ£ng phÃ­)
- Scene Ä‘á»™ng: NhÃºng quÃ¡ Ã­t (dá»… máº¥t watermark)

**Cáº£i tiáº¿n**:
```python
def detect_scene_changes(self, video_path, threshold=30):
    """
    PhÃ¡t hiá»‡n scene change báº±ng frame difference
    """
    cap = cv2.VideoCapture(video_path)
    prev_frame = None
    scene_change_frames = []
    
    frame_idx = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        
        if prev_frame is not None:
            # TÃ­nh histogram difference
            diff = cv2.absdiff(frame, prev_frame)
            diff_score = np.mean(diff)
            
            if diff_score > threshold:
                scene_change_frames.append(frame_idx)
        
        prev_frame = frame
        frame_idx += 1
    
    cap.release()
    return scene_change_frames

def smart_embed(self, video_path, watermark_path, output_path):
    """
    NhÃºng watermark vÃ o key frames (scene changes)
    """
    scene_frames = self.detect_scene_changes(video_path)
    
    # NhÃºng watermark vÃ o scene change frames + má»—i N frames
    for frame_idx in range(total_frames):
        if frame_idx in scene_frames or frame_idx % self.frame_skip == 0:
            # NhÃºng watermark
            pass
```

**Lá»£i Ã­ch** (theo paper [14]):
- Giáº£m thá»i gian xá»­ lÃ½ (Ã­t frames hÆ¡n)
- TÄƒng robustness (watermark á»Ÿ key frames)
- Tá»‘i Æ°u cho video dÃ i

---

#### ğŸŸ¡ HIGH: 3D-DCT Temporal Analysis
**TÃ i liá»‡u tham kháº£o**: [13], [15]

**Cáº£i tiáº¿n**: ThÃªm temporal dimension
```python
def embed_3d_dct(self, video_frames, watermark):
    """
    3D-DCT: 2D spatial + 1D temporal
    
    1. Láº¥y má»™t group of frames (GOP) - vÃ­ dá»¥ 8 frames
    2. Ãp dá»¥ng 2D-DCT cho má»—i frame
    3. Ãp dá»¥ng 1D-DCT theo temporal axis
    4. NhÃºng watermark vÃ o 3D-DCT coefficients
    """
    GOP_SIZE = 8
    
    for gop_start in range(0, len(video_frames), GOP_SIZE):
        gop = video_frames[gop_start:gop_start+GOP_SIZE]
        
        # 2D-DCT cho má»—i frame
        dct_frames = [self._dct2(frame) for frame in gop]
        
        # Stack thÃ nh 3D array
        dct_3d = np.stack(dct_frames, axis=2)  # Shape: (H, W, T)
        
        # 1D-DCT theo temporal axis
        for i in range(dct_3d.shape[0]):
            for j in range(dct_3d.shape[1]):
                temporal_coeffs = dct_3d[i, j, :]
                dct_3d[i, j, :] = dct(temporal_coeffs, norm='ortho')
        
        # NhÃºng watermark vÃ o mid-frequency 3D coefficients
        # ...
```

**Lá»£i Ã­ch** (theo paper [13]):
- Táº­n dá»¥ng temporal redundancy
- Robustness tá»‘t hÆ¡n frame-by-frame
- Bá»n vá»›i temporal attacks (frame dropping, averaging)

---

### 4. Quality Metrics

#### ğŸŸ¡ HIGH: ThÃªm SSIM Metric
**TÃ i liá»‡u tham kháº£o**: [17], [18]

**Kiá»ƒm tra code hiá»‡n táº¡i**: âœ… **ÄÃƒ CÃ“** trong `utils.py`

```python
def calculate_ssim(original, modified):
    """ÄÃ£ implement Ä‘Ãºng chuáº©n"""
    return ssim(original_gray, modified_gray, data_range=...)
```

**Äá» xuáº¥t**: ThÃªm vÃ o API response
```python
# Trong watermarking.py
def embed(self, ...):
    # ... nhÃºng watermark ...
    
    # TÃ­nh quality metrics
    original_img = cv2.imread(host_image_path)
    watermarked_img = cv2.imread(output_path)
    
    psnr_value = calculate_psnr(original_img, watermarked_img)
    ssim_value = calculate_ssim(original_img, watermarked_img)
    mse_value = calculate_mse(original_img, watermarked_img)
    
    return {
        'success': True,
        'quality_metrics': {
            'psnr': psnr_value,
            'ssim': ssim_value,
            'mse': mse_value
        },
        # ... other info ...
    }
```

---

#### ğŸŸ¢ MEDIUM: ThÃªm Multi-Scale SSIM
**TÃ i liá»‡u tham kháº£o**: [6] Multi-Scale Structural Similarity

**Cáº£i tiáº¿n**:
```python
def calculate_ms_ssim(original, modified, scales=5):
    """
    Multi-Scale SSIM - tá»‘t hÆ¡n single-scale SSIM
    """
    from skimage.transform import pyramid_gaussian
    
    ssim_values = []
    
    for scale in range(scales):
        # Downsample
        orig_scaled = pyramid_gaussian(original, max_layer=scale, downscale=2)
        mod_scaled = pyramid_gaussian(modified, max_layer=scale, downscale=2)
        
        # Calculate SSIM at this scale
        ssim_val = ssim(orig_scaled, mod_scaled)
        ssim_values.append(ssim_val)
    
    # Weighted average
    weights = [0.0448, 0.2856, 0.3001, 0.2363, 0.1333]
    ms_ssim = sum(w * s for w, s in zip(weights, ssim_values))
    
    return ms_ssim
```

---

### 5. Attack Simulation

#### ğŸŸ¢ MEDIUM: ThÃªm Attack Tests
**TÃ i liá»‡u tham kháº£o**: [7], [8]

**Kiá»ƒm tra code hiá»‡n táº¡i**: âœ… **ÄÃƒ CÃ“** `apply_attack()` trong `utils.py`

**Äá» xuáº¥t**: ThÃªm comprehensive attack testing
```python
def test_robustness(watermarked_image_path, original_image_path, watermark_size):
    """
    Test watermark robustness against multiple attacks
    """
    attacks = [
        ('jpeg_compression', {'quality': 90}),
        ('jpeg_compression', {'quality': 70}),
        ('jpeg_compression', {'quality': 50}),
        ('gaussian_noise', {'std': 10}),
        ('gaussian_noise', {'std': 25}),
        ('crop', {'crop_percent': 0.1}),
        ('crop', {'crop_percent': 0.2}),
        ('rotate', {'angle': 5}),
        ('rotate', {'angle': 10}),
    ]
    
    results = []
    
    for attack_name, params in attacks:
        # Apply attack
        attacked_img = apply_attack(watermarked_image, attack_name, **params)
        
        # Extract watermark
        extracted_wm = extract_watermark(attacked_img, original_img, watermark_size)
        
        # Calculate NC
        nc_value = calculate_nc(original_watermark, extracted_wm)
        
        results.append({
            'attack': attack_name,
            'params': params,
            'nc': nc_value,
            'robust': nc_value > 0.7  # Threshold
        })
    
    return results
```

---

## ğŸ“Š IV. Báº¢NG Tá»”NG Há»¢P Äá»€ XUáº¤T

| # | Cáº£i tiáº¿n | Má»©c Ä‘á»™ | Module | Effort | Impact | TÃ i liá»‡u |
|---|----------|--------|--------|--------|--------|----------|
| 1 | **ThÃªm SVD vÃ o DCT** | ğŸ”´ CRITICAL | Watermarking | High | Very High | [6][7][8] |
| 2 | **ThÃªm DWT layer** | ğŸŸ¡ HIGH | Watermarking | High | High | [7][8] |
| 3 | **Scene change detection** | ğŸŸ¡ HIGH | Video | Medium | High | [14][15] |
| 4 | **3D-DCT temporal** | ğŸŸ¡ HIGH | Video | High | High | [13][15] |
| 5 | **ThÃªm SSIM vÃ o API** | ğŸŸ¡ HIGH | Metrics | Low | Medium | [17][18] |
| 6 | **Adaptive LSB** | ğŸŸ¢ MEDIUM | Steganography | Medium | Medium | [3] |
| 7 | **Pseudorandom LSB** | ğŸŸ¢ MEDIUM | Steganography | Low | Medium | [9] |
| 8 | **Generalized Arnold** | ğŸŸ¢ MEDIUM | Utils | Low | Low | [11][12] |
| 9 | **Multi-Scale SSIM** | ğŸŸ¢ MEDIUM | Metrics | Medium | Low | [6] |
| 10 | **Attack testing** | ğŸŸ¢ MEDIUM | Testing | Medium | Medium | [7][8] |

---

## ğŸ¯ V. ROADMAP Äá»€ XUáº¤T

### Phase 1: Critical Fixes (1-2 tuáº§n)
1. âœ… Kiá»ƒm tra vÃ  xÃ¡c nháº­n Arnold Cat Map (DONE - Ä‘Ã£ Ä‘Ãºng)
2. âœ… Kiá»ƒm tra quality metrics (DONE - Ä‘Ã£ cÃ³ SSIM)
3. ğŸ”´ **ThÃªm SVD vÃ o watermarking** (quan trá»ng nháº¥t)
4. ğŸŸ¡ ThÃªm SSIM vÃ o API response

### Phase 2: High Priority (2-3 tuáº§n)
5. ğŸŸ¡ Implement DWT-DCT-SVD hybrid
6. ğŸŸ¡ Scene change detection cho video
7. ğŸŸ¡ Attack robustness testing

### Phase 3: Medium Priority (1-2 tuáº§n)
8. ğŸŸ¢ Adaptive LSB steganography
9. ğŸŸ¢ Pseudorandom embedding
10. ğŸŸ¢ 3D-DCT cho video (optional)

### Phase 4: Optimization (1 tuáº§n)
11. ğŸŸ¢ Multi-Scale SSIM
12. ğŸŸ¢ Generalized Arnold Map
13. ğŸ”µ Performance optimization

---

## ğŸ“ VI. CODE SAMPLES CHO Cáº¢I TIáº¾N QUAN TRá»ŒNG NHáº¤T

### 1. DCT-SVD Watermarking (CRITICAL)

**File má»›i**: `backend/app/core/watermarking_svd.py`

```python
"""
DCT-SVD Watermarking - Chuáº©n há»c thuáº­t
"""

import numpy as np
import cv2
from scipy.fftpack import dct, idct
from app.core.utils import arnold_cat_map, inverse_arnold_cat_map


class DCT_SVD_Watermark_V2:
    """
    DCT-SVD Watermarking theo chuáº©n há»c thuáº­t
    Tham kháº£o: 
    - [6] DWT, DCT and SVD Based Digital Image Watermarking (2012)
    - [7] Exploring DWTâ€“SVDâ€“DCT for JPEG Robustness (2014)
    """
    
    def __init__(self, block_size=8, alpha=0.1, arnold_iterations=10):
        self.block_size = block_size
        self.alpha = alpha
        self.arnold_iterations = arnold_iterations
    
    def _dct2(self, block):
        """2D DCT"""
        return dct(dct(block.T, norm='ortho').T, norm='ortho')
    
    def _idct2(self, block):
        """2D Inverse DCT"""
        return idct(idct(block.T, norm='ortho').T, norm='ortho')
    
    def _embed_svd(self, dct_block, watermark_bit):
        """
        NhÃºng watermark vÃ o singular values
        
        Thuáº­t toÃ¡n:
        1. SVD: DCT_block = U * S * V^T
        2. Modify S[0] (largest singular value)
        3. Reconstruct: DCT_block' = U * S' * V^T
        """
        # SVD decomposition
        U, S, Vt = np.linalg.svd(dct_block, full_matrices=False)
        
        # NhÃºng watermark vÃ o singular value lá»›n nháº¥t
        if watermark_bit == 1:
            S[0] = S[0] * (1 + self.alpha)
        else:
            S[0] = S[0] * (1 - self.alpha)
        
        # Reconstruct
        dct_block_modified = U @ np.diag(S) @ Vt
        
        return dct_block_modified
    
    def _extract_svd(self, watermarked_dct_block, original_dct_block):
        """
        TrÃ­ch xuáº¥t watermark bit tá»« singular values
        """
        # SVD cá»§a cáº£ 2 blocks
        _, S_wm, _ = np.linalg.svd(watermarked_dct_block, full_matrices=False)
        _, S_orig, _ = np.linalg.svd(original_dct_block, full_matrices=False)
        
        # So sÃ¡nh singular values
        ratio = S_wm[0] / S_orig[0]
        
        # TrÃ­ch xuáº¥t bit
        if ratio > 1:
            return 1
        else:
            return 0
    
    def embed(self, host_image_path, watermark_image_path, output_path):
        """
        NhÃºng watermark sá»­ dá»¥ng DCT-SVD
        """
        # Äá»c áº£nh
        host = cv2.imread(host_image_path)
        watermark = cv2.imread(watermark_image_path)
        
        if host is None or watermark is None:
            raise ValueError("Cannot read images")
        
        # Chuyá»ƒn sang YCrCb
        host_ycrcb = cv2.cvtColor(host, cv2.COLOR_BGR2YCrCb)
        host_y = host_ycrcb[:, :, 0].astype(np.float32)
        
        # Chuáº©n bá»‹ watermark
        h, w = host_y.shape
        num_blocks_h = h // self.block_size
        num_blocks_w = w // self.block_size
        watermark_size = int(np.sqrt(num_blocks_h * num_blocks_w // 4))
        watermark_size = min(watermark_size, 64)
        
        # Preprocess watermark
        watermark_gray = cv2.cvtColor(watermark, cv2.COLOR_BGR2GRAY)
        watermark_resized = cv2.resize(watermark_gray, (watermark_size, watermark_size))
        _, watermark_binary = cv2.threshold(watermark_resized, 127, 1, cv2.THRESH_BINARY)
        watermark_scrambled = arnold_cat_map(watermark_binary, self.arnold_iterations)
        watermark_flat = watermark_scrambled.flatten()
        
        # NhÃºng watermark
        watermarked_y = host_y.copy()
        watermark_idx = 0
        
        for i in range(0, h - self.block_size + 1, self.block_size):
            for j in range(0, w - self.block_size + 1, self.block_size):
                if watermark_idx >= len(watermark_flat):
                    break
                
                # Láº¥y block
                block = host_y[i:i+self.block_size, j:j+self.block_size]
                
                # DCT
                dct_block = self._dct2(block)
                
                # SVD embedding
                dct_block_modified = self._embed_svd(dct_block, watermark_flat[watermark_idx])
                
                # IDCT
                watermarked_block = self._idct2(dct_block_modified)
                watermarked_y[i:i+self.block_size, j:j+self.block_size] = watermarked_block
                
                watermark_idx += 1
            
            if watermark_idx >= len(watermark_flat):
                break
        
        # Clip vÃ  chuyá»ƒn vá» uint8
        watermarked_y = np.clip(watermarked_y, 0, 255).astype(np.uint8)
        
        # GhÃ©p láº¡i
        host_ycrcb[:, :, 0] = watermarked_y
        watermarked_bgr = cv2.cvtColor(host_ycrcb, cv2.COLOR_YCrCb2BGR)
        
        # LÆ°u áº£nh
        cv2.imwrite(output_path, watermarked_bgr)
        
        # Calculate quality metrics
        from app.core.utils import calculate_psnr, calculate_ssim, calculate_mse
        
        psnr = calculate_psnr(host, watermarked_bgr)
        ssim_val = calculate_ssim(host, watermarked_bgr)
        mse = calculate_mse(host, watermarked_bgr)
        
        return {
            'success': True,
            'watermark_size': f"{watermark_size}x{watermark_size}",
            'blocks_used': watermark_idx,
            'alpha': self.alpha,
            'arnold_iterations': self.arnold_iterations,
            'quality_metrics': {
                'psnr': float(psnr),
                'ssim': float(ssim_val),
                'mse': float(mse)
            }
        }
    
    def extract(self, watermarked_image_path, original_image_path, watermark_size):
        """
        TrÃ­ch xuáº¥t watermark sá»­ dá»¥ng DCT-SVD
        """
        # Äá»c áº£nh
        watermarked = cv2.imread(watermarked_image_path)
        original = cv2.imread(original_image_path)
        
        if watermarked is None or original is None:
            raise ValueError("Cannot read images")
        
        # Chuyá»ƒn sang kÃªnh Y
        watermarked_y = cv2.cvtColor(watermarked, cv2.COLOR_BGR2YCrCb)[:, :, 0].astype(np.float32)
        original_y = cv2.cvtColor(original, cv2.COLOR_BGR2YCrCb)[:, :, 0].astype(np.float32)
        
        h, w = watermarked_y.shape
        
        # TrÃ­ch xuáº¥t watermark bits
        extracted_bits = []
        
        for i in range(0, h - self.block_size + 1, self.block_size):
            for j in range(0, w - self.block_size + 1, self.block_size):
                if len(extracted_bits) >= watermark_size * watermark_size:
                    break
                
                # DCT cá»§a cáº£ 2 blocks
                watermarked_block = watermarked_y[i:i+self.block_size, j:j+self.block_size]
                original_block = original_y[i:i+self.block_size, j:j+self.block_size]
                
                dct_watermarked = self._dct2(watermarked_block)
                dct_original = self._dct2(original_block)
                
                # SVD extraction
                bit = self._extract_svd(dct_watermarked, dct_original)
                extracted_bits.append(bit)
            
            if len(extracted_bits) >= watermark_size * watermark_size:
                break
        
        # Reshape
        extracted_watermark = np.array(extracted_bits[:watermark_size * watermark_size])
        extracted_watermark = extracted_watermark.reshape(watermark_size, watermark_size)
        
        # Inverse Arnold
        extracted_watermark = inverse_arnold_cat_map(extracted_watermark, self.arnold_iterations)
        
        # Scale vá» 0-255
        extracted_watermark = (extracted_watermark * 255).astype(np.uint8)
        
        return extracted_watermark
```

---

## ğŸ”— VII. LINKS THAM KHáº¢O NHANH

### Official Websites
- **SSIM Official**: https://ece.uwaterloo.ca/~z70wang/research/ssim/
- **SSIM Matlab Code**: https://www.cns.nyu.edu/~lcv/ssim/

### Key Papers (ResearchGate)
- **LSB Steganography**: https://www.researchgate.net/publication/371671984
- **DCT-SVD Watermarking**: https://www.researchgate.net/publication/261039593
- **DWT-DCT-SVD Hybrid**: https://www.researchgate.net/publication/265090283
- **Video Watermarking**: https://www.researchgate.net/publication/224168687
- **Arnold Cat Map**: https://www.researchgate.net/publication/343150129

### Quality Metrics
- **PSNR vs SSIM**: https://link.springer.com/article/10.1007/s11042-020-10035-z
- **Performance Metrics**: https://www.geeksforgeeks.org/performance-metrics-for-image-steganography/

---

## âœ… VIII. CHECKLIST TRIá»‚N KHAI

### Immediate Actions (Tuáº§n 1-2)
- [ ] Review vÃ  test Arnold Cat Map (Ä‘Ã£ Ä‘Ãºng âœ…)
- [ ] Review quality metrics (Ä‘Ã£ cÃ³ SSIM âœ…)
- [ ] Implement DCT-SVD vá»›i SVD decomposition
- [ ] ThÃªm SSIM vÃ o API response
- [ ] Test robustness vá»›i JPEG compression

### Short-term (Tuáº§n 3-4)
- [ ] Implement DWT-DCT-SVD hybrid
- [ ] Scene change detection cho video
- [ ] Comprehensive attack testing
- [ ] Update documentation

### Medium-term (Tuáº§n 5-6)
- [ ] Adaptive LSB steganography
- [ ] Pseudorandom embedding
- [ ] Performance optimization

### Long-term (Tuáº§n 7+)
- [ ] 3D-DCT temporal analysis
- [ ] Multi-Scale SSIM
- [ ] Advanced security features

---

## ğŸ“š IX. Káº¾T LUáº¬N

### Äiá»ƒm máº¡nh cá»§a code hiá»‡n táº¡i:
1. âœ… LSB Steganography: ÄÃºng chuáº©n, cÃ³ encryption
2. âœ… Arnold Cat Map: Implementation chÃ­nh xÃ¡c
3. âœ… Quality Metrics: ÄÃ£ cÃ³ PSNR, SSIM, NC, MSE
4. âœ… Attack Simulation: ÄÃ£ cÃ³ framework

### Äiá»ƒm cáº§n cáº£i thiá»‡n:
1. ğŸ”´ **CRITICAL**: Watermarking thiáº¿u SVD (tÃªn gá»i DCT-SVD nhÆ°ng chá»‰ cÃ³ DCT)
2. ğŸŸ¡ **HIGH**: Thiáº¿u DWT layer Ä‘á»ƒ tÄƒng robustness
3. ğŸŸ¡ **HIGH**: Video watermarking chÆ°a cÃ³ temporal analysis
4. ğŸŸ¡ **HIGH**: ChÆ°a cÃ³ scene change detection

### Äá» xuáº¥t Æ°u tiÃªn:
**Báº¯t Ä‘áº§u vá»›i viá»‡c thÃªm SVD vÃ o watermarking** - Ä‘Ã¢y lÃ  cáº£i tiáº¿n quan trá»ng nháº¥t vÃ  cÃ³ impact lá»›n nháº¥t theo cÃ¡c paper há»c thuáº­t.

---

**TÃ i liá»‡u Ä‘Æ°á»£c táº¡o dá»±a trÃªn**: PhÃ¢n tÃ­ch code hiá»‡n táº¡i + 19 tÃ i liá»‡u há»c thuáº­t uy tÃ­n tá»« IEEE, Springer, ResearchGate, vÃ  cÃ¡c nguá»“n chÃ­nh thá»‘ng khÃ¡c.

**NgÃ y táº¡o**: 2026-01-29
